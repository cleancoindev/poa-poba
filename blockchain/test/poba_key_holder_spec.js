const PoBA = artifacts.require('PoBA')
const Web3 = require('web3')

const web3 = new Web3()
const ethAccount = [
  '0x92970dbd5c0ee6b439422bfd7cd71e1dda921a03',
  '0x38189927517c9529c5ce297a086ee8dc19c3cf21'
]
const signerPublicAddress = ethAccount[0]
const anotherAddress = ethAccount[1]
const signerHashedAddress = web3.utils.soliditySha3(signerPublicAddress)

const getPoBA = async () => PoBA.deployed()

describe('PoBA KeyHolder', () => {
  contract('KeyHolder (erc725-only API) implementation', () => {
    it('should set a default MANAGEMENT_KEY', async () => {
      const contract = await getPoBA()
      const res = await contract.getKey(signerHashedAddress)
      // res tuple positions: 0 purpose, 1: type, 2: key
      assert.equal(res[0], '1')
      assert.equal(res[1], '1')
      assert.equal(res[2], signerHashedAddress)
    })

    it('should respond to getKeyPurpose', async () => {
      const contract = await getPoBA()
      const res = await contract.getKeyPurpose(signerHashedAddress)
      assert.equal(res, '1')
    })

    it('should respond to getKeysByPurpose', async () => {
      const contract = await getPoBA()
      const res = await contract.getKeysByPurpose(1)
      assert.deepEqual(res, [signerHashedAddress])
    })

    it('should implement addKey', async () => {
      const contract = await getPoBA()
      const newKey = web3.utils.soliditySha3('0xOtherAddress')
      const res = await contract.addKey(newKey, 1, 1, { from: signerPublicAddress })
      const { event, args } = res.logs[0]
      assert.equal(event, 'KeyAdded')
      assert.equal(args.purpose, '1')
      assert.equal(args.keyType, '1')
      assert.equal(args.key, newKey)

      const getKey = await contract.getKey(newKey)
      assert.equal(getKey[2], newKey)
    })

    it('should implement removeKey', async () => {
      const contract = await getPoBA()
      const newKey = web3.utils.soliditySha3('RemoveKeyTest', { encoding: 'utf8' })
      await contract.addKey(newKey, 1, 1, { from: signerPublicAddress })
      const res = await contract.removeKey(newKey)
      const { event, args } = res.logs[0]
      assert.equal(event, 'KeyRemoved')
      assert.equal(args.purpose, '1')
      assert.equal(args.keyType, '1')
      assert.equal(args.key, newKey)
    })

    it('should not allow an existing key to be added', async () => {
      const contract = await getPoBA()
      try {
        await contract.addKey(signerHashedAddress, 1, 1)
        assert(false)
      } catch (e) {
        assert(e.message.match(/revert/))
      }
    })

    it('should not allow sender without MANAGEMENT_KEY to addKey', async () => {
      const contract = await getPoBA()
      try {
        const newKey = web3.utils.soliditySha3('0xOtherAddress')
        await contract.addKey(newKey, 1, 1, { from: anotherAddress })
        assert(false)
      } catch (e) {
        assert(e.message.match(/revert/))
      }
    })

    it("should fail to removeKey that doesn't exist", async () => {
      const contract = await getPoBA()
      try {
        const newKey = web3.utils.soliditySha3('InexistentThing', { encoding: 'utf8' })
        await contract.removeKey(newKey)
        assert(false)
      } catch (e) {
        assert(e.message.match(/revert/))
      }
    })

    it('should not allow sender without MANAGEMENT_KEY to removeKey', async () => {
      const contract = await getPoBA()
      try {
        await contract.removeKey(signerHashedAddress, { from: anotherAddress })
        assert(false)
      } catch (e) {
        assert(e.message.match(/revert/))
      }
    })

    // This will be the case when verifying erc735 claims generated by PoBA
    it('should return true when keyHasPurpose is called with the signer key and purpose "3" (CLAIM)', async () => {
      const contract = await getPoBA()
      const res = await contract.keyHasPurpose(signerHashedAddress, 3)
      assert.equal(res, true)
    })
  })
})
